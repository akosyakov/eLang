//****************************************************************************
// XText Grammar (similiar to ANTLR) for an Expression Language. 
// 
// @author Michael Vorburger
//****************************************************************************
//
// Acknowledgement: Parts of the structure of this grammar were "inspired by"
// the Java.g Java 1.6 grammar, which can be found on the Antlr website
// (http://www.antlr.org/grammar/list).
//
// NOTE: "ANTLR is an LL(k) parser-generator". Remember the LARL vs. LL etc.
// stuff from your Dragon Book (<http://en.wikipedia.org/wiki/Dragon_book>)
// Compilers class in computer science?
//
//	 @see http://en.wikipedia.org/wiki/LL_parser etc.
//	 @see The "Dragonbook", p. 176, SEC. 4.3.
//   @see http://www.antlr.org/wiki/display/ANTLR3/Left-Recursion+Removal?showChildren=false
//	 @see http://www.antlr.org/wiki/display/ANTLR3/How+to+remove+global+backtracking+from+your+grammar
// 	 @see http://javadude.com/articles/antlrtut/
//	 @see http://javadude.com/articles/lalrtoll.html
//	 @see http://www.imada.sdu.dk/~morling/antlr/issue2.htm
//   @see http://www.openarchitectureware.org/forum/viewtopic.php?showtopic=6237
//
// If none of this makes any sense whatsoever to you, you may want to go play somewhere else? ;-)  
//
// -------------------------------------------------------------------------

grammar ch.vorburger.elang.ELangDsl
	// No need for: with org.eclipse.xtext.common.Terminals, see below at the end
	hidden (COMMENT, WS)

// Because we DON'T import Terminals (where this usually is), we do need this here:
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate eLangDsl "http://www.vorburger.ch/elang/ELangDsl"

 
// -------------------------------------------------------------------------

Expression
	: RelationalORExpression;
	 
RelationalORExpression
	:  values+=RelationalANDExpression (('OR' | '||') values+=RelationalANDExpression)*;
	
RelationalANDExpression
	:  values+=RelationalComparisonExpression (('AND' | '&&') values+=RelationalComparisonExpression)*;
	
RelationalComparisonExpression
	: lvalue=AdditionOrSubtractionExpression
	(((operator='='|operator='=='|operator='!='|operator='<>'|operator='<'|operator='>'|operator='<='|operator='!>'|operator='>='|operator='!<'|operator='LIKE') 
		rvalue=AdditionOrSubtractionExpression)
	 |(operator='IN' '(' invalues+=Expression (',' invalues+=Expression)* ')')
		)?;

AdditionOrSubtractionExpression
	: values+=MultiplyOrDivideExpression ((operators+='+'|operators+='-') values+=MultiplyOrDivideExpression)*;
	
MultiplyOrDivideExpression
	: values+=UnaryPlusMinusExpression ((operators+='*'|operators+='/') values+=UnaryPlusMinusExpression)*;

// TODO Add xText "var=..." into new syntax rules below

UnaryPlusMinusExpression
	: operator='-' value=UnaryPlusMinusExpression
	| operator='+' value=UnaryPlusMinusExpression
	| value=UnaryExpressionNotPlusMinus;
	
UnaryExpressionNotPlusMinus
	: Primary 
	| ObjectNavigation
	| RelationalNOTExpression;
	
Primary
//	: Reference
	: LiteralNUMBER
	| LiteralDATE
	| LiteralDATE_TIME
	| LiteralSTRING
	| LiteralBOOLEAN
	| LiteralNULL
//	| TemporaryLiteralKeyword
;

// TODO Merge/fold Primary into UnaryExpression, this is useless now?

ObjectNavigation
	: r=ObjectN ('.' vs+=VariableOrSquareBracketFunction)*;

ObjectN
	: Variable
//	| AmpVariable
	| ParenthesisExpression
	| RoundBracketFunctionCall;

VariableOrSquareBracketFunction
	: Variable
;


Variable
	: varname=IDENTIFIER;

ParenthesisExpression
	: '(' Expression ')';

RelationalNOTExpression
	: ('NOT' | '!') abool=Expression;
	
LiteralNUMBER: number=NUMBER;
LiteralDATE: date=DATE;
LiteralDATE_TIME: dateTime=DATE_TIME;
LiteralSTRING: text=STRING;
LiteralNULL: null='NULL';

LiteralBOOLEAN: LiteralBOOLEAN_TRUE | LiteralBOOLEAN_FALSE;
LiteralBOOLEAN_TRUE: true='TRUE';
LiteralBOOLEAN_FALSE: false='FALSE';

// =========================================================================

RoundBracketFunctionCall
	: IF
	;

IF
	// TODO This example function should not be define in the core eLang, but in an extension of it.  How to do that?  
	: 'if' '(' condition=Expression ',' then=Expression (',' (else=Expression)? )? ')'; 

ExpressionOrKeyword
	: Expression
	| KEYWORD;

terminal KEYWORD:
	('A'..'Z'|'_')('A'..'Z'|'_'|'0'..'9')*;

// =========================================================================

terminal NUMBER: 
	((('0'..'9')+'.'('0'..'9')*(('e'|'E'|'d'|'D')('-'|'+')?('0'..'9')+)?)|('.'('0'..'9')+(('e'|'E'|'d'|'D')('-'|'+')?('0'..'9')+)?)|(('0'..'9')+(('e'|'E'|'d'|'D')('-'|'+')?('0'..'9')+)?));

terminal DATE:
	(('0'..'9')('0'..'9')'-'('0'..'9')('0'..'9')'-'('0'..'9')('0'..'9'))|(('0'..'9')('0'..'9')'-'('0'..'9')('0'..'9')'-'('0'..'9')('0'..'9')('0'..'9')('0'..'9'))|(('0'..'9')('0'..'9')'.'('0'..'9')('0'..'9')'.'('0'..'9')('0'..'9'))|(('0'..'9')('0'..'9')'.'('0'..'9')('0'..'9')'.'('0'..'9')('0'..'9')('0'..'9')('0'..'9'))|(('0'..'9')('0'..'9')'/'('0'..'9')('0'..'9')'/'('0'..'9')('0'..'9'))|(('0'..'9')('0'..'9')'/'('0'..'9')('0'..'9')'/'('0'..'9')('0'..'9')('0'..'9')('0'..'9'));

terminal DATE_TIME:
	(('0'..'9')('0'..'9')'-'('0'..'9')('0'..'9')'-'('0'..'9')('0'..'9')' '('0'..'9')('0'..'9')':'('0'..'9')('0'..'9')':'('0'..'9')('0'..'9'))|(('0'..'9')('0'..'9')'-'('0'..'9')('0'..'9')'-'('0'..'9')('0'..'9')('0'..'9')('0'..'9')' '('0'..'9')('0'..'9')':'('0'..'9')('0'..'9')':'('0'..'9')('0'..'9'))|(('0'..'9')('0'..'9')'.'('0'..'9')('0'..'9')'.'('0'..'9')('0'..'9')' '('0'..'9')('0'..'9')':'('0'..'9')('0'..'9')':'('0'..'9')('0'..'9'))|(('0'..'9')('0'..'9')'.'('0'..'9')('0'..'9')'.'('0'..'9')('0'..'9')('0'..'9')('0'..'9')' '('0'..'9')('0'..'9')':'('0'..'9')('0'..'9')':'('0'..'9')('0'..'9'))|(('0'..'9')('0'..'9')'/'('0'..'9')('0'..'9')'/'('0'..'9')('0'..'9')' '('0'..'9')('0'..'9')':'('0'..'9')('0'..'9')':'('0'..'9')('0'..'9'))|(('0'..'9')('0'..'9')'/'('0'..'9')('0'..'9')'/'('0'..'9')('0'..'9')('0'..'9')('0'..'9')' '('0'..'9')('0'..'9')':'('0'..'9')('0'..'9')':'('0'..'9')('0'..'9'));

terminal STRING:
	'\"' -> '\"';

terminal COMMENT: 
	'{' ( COMMENT | !'}' )* '}'; 
	// This is "hidden" through the xText hidden keyword at the very beginning of the grammar.
	// Note that XText's new "Until Token" ('{' -> '}') which first comes to mind here is not suitable, as that does not support nested comments!
	// xText & ANTLR rock... @see e.g. http://sds.sourceforge.net/src/antlr/doc/lexer.html and other doc.

terminal IDENTIFIER:
	('a'..'z'|'_')('A'..'Z'|'a'..'z'|'_'|'0'..'9')*;
		

// =========================================================================
// Here is the only thing we need from org.eclipse.xtext.common.Terminals:

terminal WS			: (' '|'\t'|'\r'|'\n')+;

